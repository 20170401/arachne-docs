{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Arachne's documentation site! Here you will find everything you need to start using Arachne, as well as reference and API documentation.\n\n\nGetting Started\n\n\n\nIf you're just getting started, you'll probably want to try out the tutorials.\n\n\nThese will walk you through the process of creating a new Arachne application, introducing the essential concepts and code along the way.\n\n\n\n\ncreating a new project\n\n\nhandling HTTP requests\n\n\nusing dependency injection\n\n\nserving static assets\n\n\nusing request interceptors\n\n\ncompiling ClojureScript\n\n\ndynamic ClojureScript development with Figwheel\n\n\n\n\nArchitectural Overview\n\n\n\nSee the \noverview\n for a high-level view of Arachne's architecture, and an explanation of how all the pieces fit together.\n\n\nModules\n\n\n\nArachne isn't a monolithic project; it is composed of many small modules, each designed to offer a vertically-integrated set of functionality.\n\n\nAll Arachne applications are built by assembling a selection of suitable modules, both from \"official\" modules and third-party modules. In fact, all Arachne projects are \nthemselves\n modules and can be required by other Arachne projects.\n\n\nArachne's core modules include:\n\n\n\n\narachne-core\n - boostrap Arachne itself\n\n\narachne-http\n - definitions and tools for dealing with basic web concepts\n\n\narachne-pedestal\n - a Pedestal-based HTTP server\n\n\narachne-assets\n - generic asset transformation pipeline\n\n\narachne-cljs\n - tools to compile ClojureScript (as part of an asset pipeline)\n\n\narachne-figwheel\n - Figwheel server for rapid, iterative ClojureScript development\n\n\n\n\nVisit these module's documentation pages for a detailed explanation of the concepts that they define, and how to use them in the context of a project.\n\n\nContributing\n\n\n\nAlthough we're still in an early alpha phase, contributions are welcome! Please see our \nContributing Guide\n to see how you can get involved.", 
            "title": "Home"
        }, 
        {
            "location": "/architecture/", 
            "text": "Configuration\n\n\nArachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.\n\n\nEvery Arachne application is defined, first and foremost, by its \nconfiguration\n. The configuration defines every aspect of the application. This includes not only thinks that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:\n\n\n\n\nDependency injection\n\n\nHTTP Routes and endpoints\n\n\nDatabase migrations\n\n\nAsset processing\n\n\nAnything else that can possibly be represented as data.\n\n\n\n\nBecause the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory \nDatomic\n (or \nDataScript\n) database.\n\n\nSchema\n\n\nConfigurations have a schema, which is assembled from the schema of the included \nmodules\n. This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust \nentity type\n model inspired by ontology definition languages such as \nOWL\n.\n\n\nThe configuration schema is intended to define the \nconcepts\n that can exist in an application, and the possible relationships between them.\n\n\nSo, while an Arachne configuration database describes a particular application in great detail, the configuration \nschema\n defines the set of \npossible\n applications for a given set of modules, and the choices that are available to application authors.\n\n\nConfig Initialization\n\n\nWhile a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.\n\n\nIn order to fulfill its goal of being easy to use, Arachne provides a \nconfiguration DSL\n that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these \nconfiguration scripts\n are a small Clojure program that writes the configuration, and the configuration is handed over to the \nruntime\n to be started once it is complete.\n\n\nRuntime\n\n\nA configuration is just data in a database. It doesn't actually \ndo\n anything until it is used to initialize an Arachne runtime.\n\n\nConfiguration databases contain \ncomponent\n entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:\n\n\n\n\nRefs to other component entities (their \ndependencies\n)\n\n\nThe fully-qualified name of a Clojure function that can be called to obtain an instance of the component.\n\n\n\n\nWhen the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.\n\n\nComponents may be of any type, although it is required that they support Clojure's \nclojure.lang.IPersistentMap\n protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by \nassoc\ning a keyword.\n\n\nComponent objects may also satisfy the \ncom.stuartsierra.Lifecycle\n protocol from Stuart Sierra's \"Component\" library), implementing \nstart\n and \nstop\n methods that will be called when the system is started and stopped, respectively.\n\n\nFinally, the runtime wires each component together with its dependencies, and calls \nstart\n on each of them in dependency order. At this point, the full Arachne system is running.\n\n\nNote that an Arachne runtime is based off a single configuration \nvalue\n. The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.\n\n\nModules\n\n\nArachne is not a monolithic library. Any Arachne application is built from many different \nmodules\n, each implementing some feature set or providing some particular functionality. Some modules, such as the base \narachne-core\n or \narachne-http\n are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.\n\n\nAt a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.\n\n\nThe distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an \narachne.edn\n file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.\n\n\nModules may declare dependencies on other modules, and an Arachne \napplication\n may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.\n\n\nModules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:\n\n\n\n\nschema\n: Each active module provides some configuration \nschema\n, defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.\n\n\ninitializers\n: When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.\n\n\nconfigure\n: Each module also has the opportunity to query and update the configuration, \nafter\n modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.\n\n\n\n\nIn addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.\n\n\nApplications\n\n\nAn Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.\n\n\nThe API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative \narachne.edn\n file in the same way that it is for modules.\n\n\nStartup Sequence\n\n\nBased on the above description of \nmodules\n and the \nruntime\n, the complete initialization and startup sequence for a specific Arachne application is as follows:\n\n\n\n\n\n\nBuilding the configuration\n\n\n\n\nA graph of active modules is determined, starting with the application and its dependencies.\n\n\nA schema is assembled by asking each active module if it has any schema to contribute (via its \nschema\n hook). A fresh configuration is built, with a schema that is the union of the active module schemas.\n\n\nIn dependency order, each module has the opportunity to update the fresh configuration using its \ninitializers\n hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.\n\n\nIn reverse dependency order, each module has the opportunity to query and update the configuration using its \nconfigure\n hook. The application will go first, and the module with the fewest dependencies (which will always be \narachne-core\n), last.\n\n\n\n\n\n\n\n\nInitializing the runtime\n\n\nThe configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.\n\n\n\n\n\n\n\nStarting the runtime\n\n\nEach component object will have it's \ncom.stuartsierra.component/start\n method called, in dependency order, after having all its own dependencies \nassoc\ned on.", 
            "title": "Architectural Overview"
        }, 
        {
            "location": "/architecture/#configuration", 
            "text": "Arachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.  Every Arachne application is defined, first and foremost, by its  configuration . The configuration defines every aspect of the application. This includes not only thinks that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:   Dependency injection  HTTP Routes and endpoints  Database migrations  Asset processing  Anything else that can possibly be represented as data.   Because the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory  Datomic  (or  DataScript ) database.", 
            "title": "Configuration"
        }, 
        {
            "location": "/architecture/#schema", 
            "text": "Configurations have a schema, which is assembled from the schema of the included  modules . This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust  entity type  model inspired by ontology definition languages such as  OWL .  The configuration schema is intended to define the  concepts  that can exist in an application, and the possible relationships between them.  So, while an Arachne configuration database describes a particular application in great detail, the configuration  schema  defines the set of  possible  applications for a given set of modules, and the choices that are available to application authors.", 
            "title": "Schema"
        }, 
        {
            "location": "/architecture/#config-initialization", 
            "text": "While a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.  In order to fulfill its goal of being easy to use, Arachne provides a  configuration DSL  that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these  configuration scripts  are a small Clojure program that writes the configuration, and the configuration is handed over to the  runtime  to be started once it is complete.", 
            "title": "Config Initialization"
        }, 
        {
            "location": "/architecture/#runtime", 
            "text": "A configuration is just data in a database. It doesn't actually  do  anything until it is used to initialize an Arachne runtime.  Configuration databases contain  component  entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:   Refs to other component entities (their  dependencies )  The fully-qualified name of a Clojure function that can be called to obtain an instance of the component.   When the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.  Components may be of any type, although it is required that they support Clojure's  clojure.lang.IPersistentMap  protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by  assoc ing a keyword.  Component objects may also satisfy the  com.stuartsierra.Lifecycle  protocol from Stuart Sierra's \"Component\" library), implementing  start  and  stop  methods that will be called when the system is started and stopped, respectively.  Finally, the runtime wires each component together with its dependencies, and calls  start  on each of them in dependency order. At this point, the full Arachne system is running.  Note that an Arachne runtime is based off a single configuration  value . The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.", 
            "title": "Runtime"
        }, 
        {
            "location": "/architecture/#modules", 
            "text": "Arachne is not a monolithic library. Any Arachne application is built from many different  modules , each implementing some feature set or providing some particular functionality. Some modules, such as the base  arachne-core  or  arachne-http  are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.  At a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.  The distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an  arachne.edn  file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.  Modules may declare dependencies on other modules, and an Arachne  application  may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.  Modules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:   schema : Each active module provides some configuration  schema , defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.  initializers : When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.  configure : Each module also has the opportunity to query and update the configuration,  after  modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.   In addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.", 
            "title": "Modules"
        }, 
        {
            "location": "/architecture/#applications", 
            "text": "An Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.  The API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative  arachne.edn  file in the same way that it is for modules.", 
            "title": "Applications"
        }, 
        {
            "location": "/architecture/#startup-sequence", 
            "text": "Based on the above description of  modules  and the  runtime , the complete initialization and startup sequence for a specific Arachne application is as follows:    Building the configuration   A graph of active modules is determined, starting with the application and its dependencies.  A schema is assembled by asking each active module if it has any schema to contribute (via its  schema  hook). A fresh configuration is built, with a schema that is the union of the active module schemas.  In dependency order, each module has the opportunity to update the fresh configuration using its  initializers  hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.  In reverse dependency order, each module has the opportunity to query and update the configuration using its  configure  hook. The application will go first, and the module with the fewest dependencies (which will always be  arachne-core ), last.     Initializing the runtime  The configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.    Starting the runtime  Each component object will have it's  com.stuartsierra.component/start  method called, in dependency order, after having all its own dependencies  assoc ed on.", 
            "title": "Startup Sequence"
        }, 
        {
            "location": "/tutorials/creating-a-project/", 
            "text": "Creating an Arachne Project\n\n\n\nThis in-depth tutorial describes how to create a simple Arachne project from scratch, explaining everything as it goes. You can find the complete source code used in this tutorial on \nGithub\n.\n\n\n\nIn practice, you will probably want to start new Arachne projects by cloning an existing template app. However, when learning Arachne, it is instructive to go through this excercise and create each part piece by piece, to gain an understanding of what the parts are and how they work together.\n\n\n\n\nTo make the most of this particular tutorial, you will be most effective if you already:\n\n\n\n\nHave a basic knowledge of the Clojure language\n\n\nAre comfortable with Clojure protocols and records\n\n\nHave a Clojure editing environment that you are happy with. You should be able to launch a REPL, create Clojure source files, and evaluate forms from your source files in your REPL.\n\n\n\n\nCreating the project\n\n\nFor this tutorial, we'll use \nleiningen\n to assemble our dependencies and launch a JVM.\n\n\n\nOf course, you can also use Arachne with \nboot\n or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.\n\n\n\n\nFirst, let's create a new lein project. At the command line, navigate to a directory of your choice and type \nlein new myproj\n. This will create a directory called \nmyproj\n containing a \nproject.clj\n file and several stubbed source and test files.\n\n\nFor this tutorial, we will not be using the \n/test\n, \n/doc\n, \nREADME.md\n, \nLICENSE\n or \nCHANGELOG.md\n files, so we will delete them to keep things crystal clear.\n\n\nAfter this step, your directory structure should be as follows:\n\n\nmyproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nEdit the \nproject.clj\n file to contain the following contents:\n\n\n(defproject myproj \n0.1.0-SNAPSHOT\n\n  :dependencies [[org.clojure/clojure \n1.9.0-alpha14\n]\n                 [org.arachne-framework/arachne-core \n0.1.0-master-0081-0ab2073\n]\n                 [datascript \n0.15.5\n]\n                 [ch.qos.logback/logback-classic \n1.1.3\n]]\n  :repositories [[\narachne-dev\n\n                  \nhttp://maven.arachne-framework.org/artifactory/arachne-dev\n]])\n\n\n\n\nYou can just cut and paste for now, but if you're curious about what any of this means:\n\n\n\n\nArachne leverages the new \nclojure.spec\n library heavily, and therefore requires the latest alpha of Clojure 1.9\n\n\nThe version number for Arachne looks funky. WTF is \n0.1.0-master-0081-0ab2073\n supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format: \nsemver\n-\nbranch\n-\ncommit-idx\n-\ncommit-sha\n. This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that \n0081\n is newere than \n0080\n and older than \n0082\n. Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date.\n\n\nWe've included DataScript on the classpath, but we also could have used \nDatomic\n or \nDatomic Free\n. Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)\n\n\nLogging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.\n\n\nWe need to add the \narachne-dev\n repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.\n\n\n\n\nWriting a component\n\n\nArachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines a the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on \ndependency injection\n.\n\n\nTo get started with the simplest possible Arachne application, we need to do two things:\n\n\n\n\nCreate a SierraComponent that our system will use\n\n\nDefine a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)\n\n\n\n\nFirst, let's pop open \nsrc/myproj/core.clj\n and define a component (after requiring a couple namespaces):\n\n\n(ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg \nHello, world!\n)\n    this)\n  (stop [this]\n    (log/info :msg \nGoodnight!\n)\n    this))\n\n\n\n\nThis is pretty straightforward; this code simply defines a component that satisfies Component's \nLifecycle\n protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.\n\n\nIf you want, at this point, you can verify that your component is working as expected using the REPL:\n\n\n(def w (-\nWidget))\n;;=\n #'myproj.core/w\n(c/start w)\n;;=\n #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nNow, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:\n\n\n(defn make-widget\n  \nConstructor for a Widget\n\n  []\n  (-\nWidget))\n\n\n\n\nGreat! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.\n\n\nWriting a configuration script\n\n\nWhat is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.\n\n\nBut, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be \nsuper\n readable.\n\n\nSo Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a \nconfig script\n, and when the config script is executed, it will populate the config database with everything it needs.\n\n\nSo what does a config script look like? For our very simple app, it looks like this:\n\n\n(require '[arachne.core.dsl :as a])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/widget-1])\n\n\n\n\nSave this to a file called \nconfig/myproj.clj\n in your project directory.\n\n\nThere are two things worth unpacking here, before we dive into what these forms mean.\n\n\nFirst, you will notice that the file has no namespace. That is fully intentional. It is \nnot part of your project's codebase\n. It is a config script. No code should require it. It's not in your \n/src\n directory, so it isn't even on the classpath!\n\n\nIn a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your \nreal\n application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.\n\n\nSecond, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there \nis\n no current configuration, and so trying to call a DSL form will throw an error.\n\n\nWith that out of the way, let's talk about what these functions do.\n\n\nThe \narachne.core.dsl/component\n function defines a component, in the configuration. The first argument (here the keyword \n:myproj/widget-1\n) is a unique ID for our component. Anywhere in our config where we refer to \n:myproj/widget-1\n, we're talking about the same entity in the configuration DB.\n\n\nThe second argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only \nidentifies\n the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.\n\n\nThe \narachne.core.dsl/component\n function also takes an optional third argument, to specify the dependencies of the component, but we'll ignore that for now.\n\n\nThe \narachne.core.dsl/runtime\n function defines a named \nruntime entity\n in the application's configuration. The runtime entity groups components together and specifies which ones should be instanted when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.\n\n\nIn this case we just have one runtime (named \n:myproj/runtime\n), which identifies our one and only component (\n:myproj/widget-1\n). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.\n\n\nApplication metadata\n\n\nFinally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.\n\n\nTo do this, we need write an \narachne.edn\n file, somewhere on our classpath, that contains this information. Let's put it in \n/resources\n for now:\n\n\n[{:arachne/name :myproj/app\n  :arachne/inits [\nconfig/myproj.clj\n]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]\n\n\n\n\n\n\n:arachne/name\n is just the name of our application as a whole.\n\n\n:arachne/inits\n is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the process-relative filename of the config script that we wrote in the previous section.\n\n\n:arachne/dependencies\n specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named \n:org.arachne-framework/arachne-core\n. All the modules we want to use must also be on the classpath (that is, specified in our \nproject.clj\n, which \narachne.core\n is.)\n\n\n\n\nThat's it! Our Arachne application is now ready to run.\n\n\nAt this point, your project directory structure should look like this:\n\n\nmyproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nRunning the application\n\n\nThere are two ways to run an Arachne application:\n\n\n\n\nFrom the REPL, as you would during development\n\n\nFrom the command line, as you might in production\n\n\n\n\nRunning from the REPL\n\n\nWith a REPL open, start by requiring the namespaces we'll need to get things rolling:\n\n\n(require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])\n\n\n\n\nThen, we can build a configuration value:\n\n\n(def cfg (arachne/config :myproj/app))\n;; =\n #'user/cfg\n\n\n\n\nInside this seemingly simple function call, a \nhuge\n number of things are happening under the hood.\n\n\n\n\nWe pass in only the name of our application, \n:myproj/app\n\n\nThe application metadata is loaded from the \narachne.edn\n file.\n\n\nA new config is built, using schema derived from all the modules that we depend on.\n\n\nOur config script is evaluated (you can put some \nprintlns\n in it, if you like, to prove to yourself that this is the case)\n\n\nAll the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.\n\n\n\n\nThe value that is returned is a configuration object: an immutable, in-memory database.\n\n\nSo far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:\n\n\n(def rt (arachne/runtime cfg :myproj/runtime))\n;; =\n #'user/rt\n\n\n\n\nWhat just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.\n\n\nAll of our constructor functions have been called (try putting a \nprintln\n in the constructor function to convince yourself that this is true), but we haven't yet called Component's \nstart\n method on our system, so nothing's actually happened yet. '\n\n\nLet's run it!\n\n\n(def started-rt (c/start rt))\n=\n #'user/started-rt\n\n\n\n\nNote that it's important to capture the result of calling \nstart\n; we'll need it to pass to \nstop\n if we ever want to stop our system.\n\n\nIn our console, we should also see two log messages:\n\n\n22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nOne is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.\n\n\nYou can call \nstop\n on the runtime when you're done:\n\n\n(c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg \nStopping Arachne runtime\n, :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg \nGoodnight!\n, :line nil}\n\n\n\n\nThere are a few gotchas to remember when doing REPL-driven development with Arachne:\n\n\n\n\nIf you change anything in your config script, you'll need to stop your runtime and rebuild your config from \n(arachne.core/config)\n. The config that it returns is immutable, and can't be updated once it's been used to start a runtime.\n\n\nIf you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from \n(arachne.core/runtime)\n. Changing the definition of a component won't change the instances that are referenced inside the runtime object.\n\n\n\n\nIn the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things manually, but for now it's the responsibility of users to keep track of them.\n\n\nRunning from the command line\n\n\nRunning from the command line is, fortunately, even more straightforward. Arachne defines an \narachne.run\n namespace, which contains a \n-main\n method that can be used to easily launch an Arachne application.\n\n\nYou can set \narachne.run\n as the default \n:main\n namespace in leiningen by adding the following key to your \nproject.clj\n:\n\n\n:main arachne.run\n\n\n\n\nThen, you can start your Arachne application from the command line by calling \nlein run\n and passing it two arguments: the name of your application as defined in \narachne.edn\n, and the name of the runtime you want to start as defined in your init script:\n\n\nlein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg \nLaunching Arachne application\n, :name \n:myproj/app\n, :runtime \n:myproj/runtime\n, :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nYou should see the same log messages, indicating that the application (including your component) has started correctly.\n\n\nYou will need to terminate the program manually when you're done, since it won't exit by itself.\n\n\nError reporting\n\n\nThere is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.\n\n\nTo see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:\n\n\n(a/component :widget-1 'myproj.core/make-widget)\n\n\n\n\nWhen we try to build a config based on this script, it throws an exception:\n\n\n(def cfg (arachne/config :myproj/app))\n;; CompilerException arachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n\n\n\n\nThis should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...\n\n\n(.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3657)\n    at clojure.lang.Compiler$DefExpr.eval(Compiler.java:451)\n    at clojure.lang.Compiler.eval(Compiler.java:6983)\n\n\nSNIP MANY MANY LINES\n\n\n    at arachne.core.module$initialize$fn__5505.invoke(module.clj:161)\n    ... 48 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/component` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$component.invokeStatic(dsl.clj:57)\n    at arachne.core.dsl$component.doInvoke(dsl.clj:57)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invokeStatic(myproj.clj:3)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invoke(myproj.clj:3)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 56 more\n\n\n\n\nIf you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to \narachne.core.dsl/component\n. Fine.\n\n\nFortunately, with Arachne, there is a slightly better alternative: invoke \n(arachne.error/explain)\n, with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the onecurrently bound to \n*e\n, in Clojure's REPL).\n\n\nThe output of \nexplain\n is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:\n\n\n\n\nHopefully, you find this to be a better alternative.\n\n\nOne of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Creating a Project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#creating-the-project", 
            "text": "For this tutorial, we'll use  leiningen  to assemble our dependencies and launch a JVM.  \nOf course, you can also use Arachne with  boot  or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.  First, let's create a new lein project. At the command line, navigate to a directory of your choice and type  lein new myproj . This will create a directory called  myproj  containing a  project.clj  file and several stubbed source and test files.  For this tutorial, we will not be using the  /test ,  /doc ,  README.md ,  LICENSE  or  CHANGELOG.md  files, so we will delete them to keep things crystal clear.  After this step, your directory structure should be as follows:  myproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj  Edit the  project.clj  file to contain the following contents:  (defproject myproj  0.1.0-SNAPSHOT \n  :dependencies [[org.clojure/clojure  1.9.0-alpha14 ]\n                 [org.arachne-framework/arachne-core  0.1.0-master-0081-0ab2073 ]\n                 [datascript  0.15.5 ]\n                 [ch.qos.logback/logback-classic  1.1.3 ]]\n  :repositories [[ arachne-dev \n                   http://maven.arachne-framework.org/artifactory/arachne-dev ]])  You can just cut and paste for now, but if you're curious about what any of this means:   Arachne leverages the new  clojure.spec  library heavily, and therefore requires the latest alpha of Clojure 1.9  The version number for Arachne looks funky. WTF is  0.1.0-master-0081-0ab2073  supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format:  semver - branch - commit-idx - commit-sha . This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that  0081  is newere than  0080  and older than  0082 . Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date.  We've included DataScript on the classpath, but we also could have used  Datomic  or  Datomic Free . Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)  Logging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.  We need to add the  arachne-dev  repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.", 
            "title": "Creating the project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-component", 
            "text": "Arachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines a the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on  dependency injection .  To get started with the simplest possible Arachne application, we need to do two things:   Create a SierraComponent that our system will use  Define a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)   First, let's pop open  src/myproj/core.clj  and define a component (after requiring a couple namespaces):  (ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg  Hello, world! )\n    this)\n  (stop [this]\n    (log/info :msg  Goodnight! )\n    this))  This is pretty straightforward; this code simply defines a component that satisfies Component's  Lifecycle  protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.  If you want, at this point, you can verify that your component is working as expected using the REPL:  (def w (- Widget))\n;;=  #'myproj.core/w\n(c/start w)\n;;=  #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg  Hello, world! , :line nil}  Now, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:  (defn make-widget\n   Constructor for a Widget \n  []\n  (- Widget))  Great! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.", 
            "title": "Writing a component"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-configuration-script", 
            "text": "What is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.  But, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be  super  readable.  So Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a  config script , and when the config script is executed, it will populate the config database with everything it needs.  So what does a config script look like? For our very simple app, it looks like this:  (require '[arachne.core.dsl :as a])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/widget-1])  Save this to a file called  config/myproj.clj  in your project directory.  There are two things worth unpacking here, before we dive into what these forms mean.  First, you will notice that the file has no namespace. That is fully intentional. It is  not part of your project's codebase . It is a config script. No code should require it. It's not in your  /src  directory, so it isn't even on the classpath!  In a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your  real  application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.  Second, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there  is  no current configuration, and so trying to call a DSL form will throw an error.  With that out of the way, let's talk about what these functions do.  The  arachne.core.dsl/component  function defines a component, in the configuration. The first argument (here the keyword  :myproj/widget-1 ) is a unique ID for our component. Anywhere in our config where we refer to  :myproj/widget-1 , we're talking about the same entity in the configuration DB.  The second argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only  identifies  the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.  The  arachne.core.dsl/component  function also takes an optional third argument, to specify the dependencies of the component, but we'll ignore that for now.  The  arachne.core.dsl/runtime  function defines a named  runtime entity  in the application's configuration. The runtime entity groups components together and specifies which ones should be instanted when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.  In this case we just have one runtime (named  :myproj/runtime ), which identifies our one and only component ( :myproj/widget-1 ). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.", 
            "title": "Writing a configuration script"
        }, 
        {
            "location": "/tutorials/creating-a-project/#application-metadata", 
            "text": "Finally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.  To do this, we need write an  arachne.edn  file, somewhere on our classpath, that contains this information. Let's put it in  /resources  for now:  [{:arachne/name :myproj/app\n  :arachne/inits [ config/myproj.clj ]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]   :arachne/name  is just the name of our application as a whole.  :arachne/inits  is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the process-relative filename of the config script that we wrote in the previous section.  :arachne/dependencies  specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named  :org.arachne-framework/arachne-core . All the modules we want to use must also be on the classpath (that is, specified in our  project.clj , which  arachne.core  is.)   That's it! Our Arachne application is now ready to run.  At this point, your project directory structure should look like this:  myproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj", 
            "title": "Application metadata"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-the-application", 
            "text": "There are two ways to run an Arachne application:   From the REPL, as you would during development  From the command line, as you might in production", 
            "title": "Running the application"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-repl", 
            "text": "With a REPL open, start by requiring the namespaces we'll need to get things rolling:  (require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])  Then, we can build a configuration value:  (def cfg (arachne/config :myproj/app))\n;; =  #'user/cfg  Inside this seemingly simple function call, a  huge  number of things are happening under the hood.   We pass in only the name of our application,  :myproj/app  The application metadata is loaded from the  arachne.edn  file.  A new config is built, using schema derived from all the modules that we depend on.  Our config script is evaluated (you can put some  printlns  in it, if you like, to prove to yourself that this is the case)  All the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.   The value that is returned is a configuration object: an immutable, in-memory database.  So far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:  (def rt (arachne/runtime cfg :myproj/runtime))\n;; =  #'user/rt  What just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.  All of our constructor functions have been called (try putting a  println  in the constructor function to convince yourself that this is true), but we haven't yet called Component's  start  method on our system, so nothing's actually happened yet. '  Let's run it!  (def started-rt (c/start rt))\n=  #'user/started-rt  Note that it's important to capture the result of calling  start ; we'll need it to pass to  stop  if we ever want to stop our system.  In our console, we should also see two log messages:  22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg  Hello, world! , :line nil}  One is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.  You can call  stop  on the runtime when you're done:  (c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg  Stopping Arachne runtime , :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg  Goodnight! , :line nil}  There are a few gotchas to remember when doing REPL-driven development with Arachne:   If you change anything in your config script, you'll need to stop your runtime and rebuild your config from  (arachne.core/config) . The config that it returns is immutable, and can't be updated once it's been used to start a runtime.  If you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from  (arachne.core/runtime) . Changing the definition of a component won't change the instances that are referenced inside the runtime object.   In the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things manually, but for now it's the responsibility of users to keep track of them.", 
            "title": "Running from the REPL"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-command-line", 
            "text": "Running from the command line is, fortunately, even more straightforward. Arachne defines an  arachne.run  namespace, which contains a  -main  method that can be used to easily launch an Arachne application.  You can set  arachne.run  as the default  :main  namespace in leiningen by adding the following key to your  project.clj :  :main arachne.run  Then, you can start your Arachne application from the command line by calling  lein run  and passing it two arguments: the name of your application as defined in  arachne.edn , and the name of the runtime you want to start as defined in your init script:  lein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg  Launching Arachne application , :name  :myproj/app , :runtime  :myproj/runtime , :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg  Hello, world! , :line nil}  You should see the same log messages, indicating that the application (including your component) has started correctly.  You will need to terminate the program manually when you're done, since it won't exit by itself.", 
            "title": "Running from the command line"
        }, 
        {
            "location": "/tutorials/creating-a-project/#error-reporting", 
            "text": "There is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.  To see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:  (a/component :widget-1 'myproj.core/make-widget)  When we try to build a config based on this script, it throws an exception:  (def cfg (arachne/config :myproj/app))\n;; CompilerException arachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)  This should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...  (.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3657)\n    at clojure.lang.Compiler$DefExpr.eval(Compiler.java:451)\n    at clojure.lang.Compiler.eval(Compiler.java:6983) SNIP MANY MANY LINES \n\n    at arachne.core.module$initialize$fn__5505.invoke(module.clj:161)\n    ... 48 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/component` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$component.invokeStatic(dsl.clj:57)\n    at arachne.core.dsl$component.doInvoke(dsl.clj:57)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invokeStatic(myproj.clj:3)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invoke(myproj.clj:3)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 56 more  If you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to  arachne.core.dsl/component . Fine.  Fortunately, with Arachne, there is a slightly better alternative: invoke  (arachne.error/explain) , with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the onecurrently bound to  *e , in Clojure's REPL).  The output of  explain  is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:   Hopefully, you find this to be a better alternative.  One of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Error reporting"
        }, 
        {
            "location": "/tutorials/http-requests/", 
            "text": "Handling HTTP Requests\n\n\n\nThis tutorial extends the project started in the \ngetting started tutorial\n and adds the Pedestal module. It shows how to define and start a HTTP server, and handle incoming HTTP requests using custom handlers functions.\n\n\nYou can find the complete source code used in this tutorial on \nGithub\n.\n\n\nTo make the most of this particular tutorial, you will be most effective if you have already read and understood the material in the \ngetting started tutorial\n\n\nEnabling the Pedestal module\n\n\nTo make our application into an HTTP server, we'll need add the \narachne-pedestal\n Arachne module to our app. \nPedestal\n is an industrial strength HTTP server for Clojure, and Arachne wraps it, inheriting the benefits that it provides.\n\n\n\n\nThe \narachne-pedestal\n module uses Pedestal, as do many of Arachne's official modules, because we needed to pick \nsome\n http server and Pedestal fit the bill nicely. However, there's nothing about Arachne itself that requires Pedestal; in theory you could also (for example) build an \"arachne-ring\" module to fill the same role. Most of Arachne's container-agnostic HTTP concepts and handling code is already pulled out into a separate \narachne-http\n module (which \narachne-pedestal\n depends on) and could be freely reused.\n\n\nOf course, any modules that depend on \narachne-pedestal\n would then also need to be modified, or alternatives created.\n\n\n\n\n\nFirst, we'll need to add a Leiningen dependency, to make sure \narachne-pedestal\n is on our classpath. Because \narachne-pedestal\n ultimately depends on \narachne-core\n as well, we can actually \nreplace\n \narachne-core\n in the \nproject.clj\n: it will still be required.\n\n\nAfter adding it, your leiningen dependencies should look something like this:\n\n\n:dependencies [[org.clojure/clojure \n1.9.0-alpha14\n]\n               [org.arachne-framework/arachne-pedestal \n0.1.0-master-0036-59ecd65\n]\n               [datascript \n0.15.5\n]\n               [ch.qos.logback/logback-classic \n1.1.3\n]]\n\n\n\n\nThen, we need to update the \narachne.edn\n file to indicate that our application should activate the Pedestal module. Just like \nproject.clj\n, we can actually replace the core module; because the Pedestal depends on it transitively, we no longer need depend on it explicitly.\n\n\n[{:arachne/name :myproj/app\n  :arachne/inits [\nconfig/myproj.clj\n]\n  :arachne/dependencies [:org.arachne-framework/arachne-pedestal]}]\n\n\n\n\nWriting a handler function\n\n\nIn Arachne (and Pedestal) (and Ring), a handler function is a function which takes a request as its argument, and returns a response. Both the request and the response are represented as Clojure maps.\n\n\nBelow is what is possibly the simplest possible handler function. We will add it to our app, in \nsrc/myproj/core.clj\n:\n\n\n(defn hello-handler\n  [req]\n  {:status 200\n   :body \nHello, world!\n})\n\n\n\n\nThis function just responds with \n\"Hello, world!\"\n to any incoming request. Easy enough!\n\n\nThis is literally all of the project code we need to write to turn our application into a web application. Everything else will be defined in the Arachne configuration.\n\n\nServer configuraton\n\n\nNow, for the interesting part: updating the config script to start a HTTP server serving up our handler.\n\n\nFirst, we will need to define a Component representing our handler function. Add the following to your config script:\n\n\n(require '[arachne.http.dsl :as h])\n\n(h/handler :myproj/hello 'myproj.core/hello-handler)\n\n\n\n\nThe \narachne.http.dsl/handler\n function looks very much like the \narachne.core.dsl/component\n function we used earlier. This is no accident! In fact, \nhandler\n is actually defining a component, too: just a specific kind of component. The difference is that the function specified should identify a handler function (the one we just wrote) instead of being a constructor that can return an arbitrary object. Note that we still need to give our handler component a name: \n:myproj/hello\n. We'll need to refer to this in the next step.\n\n\nNext, we will add some DSL forms that define a HTTP server, and tell it how to serve our handler function:\n\n\n(require '[arachne.pedestal.dsl :as p])\n\n(p/server :myproj/server 8080\n\n  (h/endpoint :get \n/\n :myproj/hello)\n\n  )\n\n\n\n\nThe \narachne.pedestal.dsl/server\n form creates yet another component entity named \n:myproj/server\n. Instead of passing a symbol that identifies a constructor or a handler function, \nserver\n requires a port.\n\n\n\nSee the pattern? Most Arachne DSL functions that define a component entity take the Arachne ID of the component as their first argument, and then other functions can refer to that ID to connect components together.\n\n\n\n\nNested \ninside\n the server element, we declare a HTTP endpoint, using the \narachne.http.dsl/endpoint\n function. This function takes three arguments:\n\n\n\n\nThe HTTP method that this endpoint responds to, as a Clojure keyword. You may also pass a set of keywords if the endpoint can respond to multiple request types.\n\n\nThe route to which to \"attach\" the endpoint: requests to this route will be delegated to the endpoint.\n\n\nThe Arachne ID of the endpoint itself. This is a reference to the handler endpoint we declared above.\n\n\n\n\nIn general, this is how an Arachne applications always define their routing structure: A \nserver\n DSL form, with nested forms for all the endpoints inside.\n\n\nAgain, it cannot be emphasized enough: these DSL forms do not create an actual Pedestal server. They create entities in the config that define the server. No server is actually started, and no ports will be opened until we use this config to initialize a runtime and call \nstart\n.\n\n\nThere's just one more step: we need to tell Arachne that this HTTP server is part of our runtime, and should be started when the runtime starts. Replace the existing \na/runtime\n call with:\n\n\n(a/runtime :myproj/runtime [:myproj/server])\n\n\n\n\nAt this point, your full configuration script should look something like this:\n\n\n(require '[arachne.core.dsl :as a])\n(require '[arachne.http.dsl :as h])\n(require '[arachne.pedestal.dsl :as p])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/server])\n\n(h/handler :myproj/hello 'myproj.core/hello-handler)\n\n(p/server :myproj/server 8080\n\n  (h/endpoint :get \n/\n :myproj/hello)\n\n  )\n\n\n\n\nRunning the server\n\n\nAt this point, we can start a runtime. But before we do, we should configure Logback to log a little bit less verbosely. If no \nlogback.xml\n file is supplied, the default log level is \nDEBUG\n, and Pedestal dumps a \nlot\n of debug messages. Copy and paste the following \nlogback.xml\n file into your \nresources\n directory to set a default log level of \nINFO\n and cut down on the noise:\n\n\nconfiguration debug=\nfalse\n\n\n    -\nappender name=\nSTDOUT\n class=\nch.qos.logback.core.ConsoleAppender\n\n        \nencoder\n\n            \npattern\n%d{HH:mm:ss.SSS} %-5level - %logger{36} %msg%n\n/pattern\n\n        \n/encoder\n\n    \n/appender\n\n\n    \nroot level=\nINFO\n\n      \nappender-ref ref=\nSTDOUT\n/\n\n    \n/root\n\n\n\n/configuration\n\n\n\n\n\nThen, once logging is set up, we can run the server. Here, we'll use the command line (for simplicity), though of course you could use a REPL as described in the \ncreating a project\n tutorial.\n\n\nlein run :myproj/app :myproj/runtime\n\n\n\n\nYou should see log output indicating that the server has started.\n\n\nHit the \nhttp://localhost:8080/\n URL to see your endpoint in action!\n\n\nPath params\n\n\nYou aren't limited to specific, hardcoded routes. Arachne (via Pedestal) also allows you to use a semicolon in a route name to create a \npath parameter\n. Values at that path are then available in the request, in a map under the \n:path-params\n key.\n\n\nLet's try it out with a new handler function:\n\n\n(defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (if (empty? name)\n             \nWho's there!?\n\n             (str \nHello, \n name \n!\n))}))\n\n\n\n\nAnd the corresponding line in the configuration script, inside our server:\n\n\n(h/endpoint :get \n/greet/:name\n (h/handler 'myproj.core/greeter))\n\n\n\n\nThe \n:name\n key in the path indicates that any value at that URL should be bound to the \n:name\n key in the request's \n:path-params\n.\n\n\nYou may also notice that we've defined the endpoint in a different way than we did before. Instead of giving the handler component an Arachne ID and then referencing it by ID, we defined it anonymously and inline, declaring it \ninside\n the \nh/endpoint\n form.\n\n\nThat works fine! Arachne DSL functions which define components (including \narachne.core.dsl/component\n, \narachne.http.dsl/handler\n and \narachne.pedestal.dsl/server\n, that we've seen so far) all return the entity ID of their newly created config entity, in the context configuration. And DSL forms which reference another component (such as \narachne.http.dsl/endpoint\n) can accept either an Arachne ID, \nor\n an entity ID as a component identifier.\n\n\nThis means that the following three forms are equivalent:\n\n\n(h/endpoint :get \n/greet/:name\n (h/handler 'myproj.core/greeter))\n\n\n\n\n(def handler-eid (h/handler 'myproj.core/greeter))\n(h/endpoint :get \n/greet/:name\n handler-eid)\n\n\n\n\n(h/handler :myproj/greeter 'myproj.core/greeter)\n(h/endpoint :get \n/greet/:name\n :myproj/greeter)\n\n\n\n\nAnd, of course, we could both define a handler inline \nand\n give it an Arachne ID:\n\n\n(h/endpoint :get \n/greet/:name\n (h/handler :myproj/greeter 'myproj.core/greeter))\n\n\n\n\nYou can use whichever of these variations leads to the cleanest and most readable config scripts.\n\n\nDo note, though, that if you don't give a component an Arachne ID, and you don't capture the return value of the DSL function, you've just created a component entity that you have no ability to refer to, which will be pretty useless to you.\n\n\nComponents and the runtime\n\n\nIf you were looking for it, you might also have noticed that we're not getting the \"Hello World\" message from our Widget component, which we built in the last tutorial. That's because when we edited our \n(a/runtime)\n form to include \n:myproj/server\n instead of \n:myproj/widget-1\n, we removed all references to the widget from the components we told Arachne to start. Because nothing was depending on it, it was neither instantiated nor started with the rest of the System.\n\n\nIf we did want to have our custom component to start up, we can add it to the runtime, along with our HTTP server, like so:\n\n\n(a/runtime :myproj/runtime [:myproj/server :myproj/widget-1])\n\n\n\n\nNow, our custom component will start up alongside the server itself.\n\n\nFor much more on components and component dependencies, see the next tutorial on \ndependency injection\n.", 
            "title": "Handling HTTP Requests"
        }, 
        {
            "location": "/tutorials/http-requests/#enabling-the-pedestal-module", 
            "text": "To make our application into an HTTP server, we'll need add the  arachne-pedestal  Arachne module to our app.  Pedestal  is an industrial strength HTTP server for Clojure, and Arachne wraps it, inheriting the benefits that it provides.   The  arachne-pedestal  module uses Pedestal, as do many of Arachne's official modules, because we needed to pick  some  http server and Pedestal fit the bill nicely. However, there's nothing about Arachne itself that requires Pedestal; in theory you could also (for example) build an \"arachne-ring\" module to fill the same role. Most of Arachne's container-agnostic HTTP concepts and handling code is already pulled out into a separate  arachne-http  module (which  arachne-pedestal  depends on) and could be freely reused.  Of course, any modules that depend on  arachne-pedestal  would then also need to be modified, or alternatives created.   First, we'll need to add a Leiningen dependency, to make sure  arachne-pedestal  is on our classpath. Because  arachne-pedestal  ultimately depends on  arachne-core  as well, we can actually  replace   arachne-core  in the  project.clj : it will still be required.  After adding it, your leiningen dependencies should look something like this:  :dependencies [[org.clojure/clojure  1.9.0-alpha14 ]\n               [org.arachne-framework/arachne-pedestal  0.1.0-master-0036-59ecd65 ]\n               [datascript  0.15.5 ]\n               [ch.qos.logback/logback-classic  1.1.3 ]]  Then, we need to update the  arachne.edn  file to indicate that our application should activate the Pedestal module. Just like  project.clj , we can actually replace the core module; because the Pedestal depends on it transitively, we no longer need depend on it explicitly.  [{:arachne/name :myproj/app\n  :arachne/inits [ config/myproj.clj ]\n  :arachne/dependencies [:org.arachne-framework/arachne-pedestal]}]", 
            "title": "Enabling the Pedestal module"
        }, 
        {
            "location": "/tutorials/http-requests/#writing-a-handler-function", 
            "text": "In Arachne (and Pedestal) (and Ring), a handler function is a function which takes a request as its argument, and returns a response. Both the request and the response are represented as Clojure maps.  Below is what is possibly the simplest possible handler function. We will add it to our app, in  src/myproj/core.clj :  (defn hello-handler\n  [req]\n  {:status 200\n   :body  Hello, world! })  This function just responds with  \"Hello, world!\"  to any incoming request. Easy enough!  This is literally all of the project code we need to write to turn our application into a web application. Everything else will be defined in the Arachne configuration.", 
            "title": "Writing a handler function"
        }, 
        {
            "location": "/tutorials/http-requests/#server-configuraton", 
            "text": "Now, for the interesting part: updating the config script to start a HTTP server serving up our handler.  First, we will need to define a Component representing our handler function. Add the following to your config script:  (require '[arachne.http.dsl :as h])\n\n(h/handler :myproj/hello 'myproj.core/hello-handler)  The  arachne.http.dsl/handler  function looks very much like the  arachne.core.dsl/component  function we used earlier. This is no accident! In fact,  handler  is actually defining a component, too: just a specific kind of component. The difference is that the function specified should identify a handler function (the one we just wrote) instead of being a constructor that can return an arbitrary object. Note that we still need to give our handler component a name:  :myproj/hello . We'll need to refer to this in the next step.  Next, we will add some DSL forms that define a HTTP server, and tell it how to serve our handler function:  (require '[arachne.pedestal.dsl :as p])\n\n(p/server :myproj/server 8080\n\n  (h/endpoint :get  /  :myproj/hello)\n\n  )  The  arachne.pedestal.dsl/server  form creates yet another component entity named  :myproj/server . Instead of passing a symbol that identifies a constructor or a handler function,  server  requires a port.  \nSee the pattern? Most Arachne DSL functions that define a component entity take the Arachne ID of the component as their first argument, and then other functions can refer to that ID to connect components together.  Nested  inside  the server element, we declare a HTTP endpoint, using the  arachne.http.dsl/endpoint  function. This function takes three arguments:   The HTTP method that this endpoint responds to, as a Clojure keyword. You may also pass a set of keywords if the endpoint can respond to multiple request types.  The route to which to \"attach\" the endpoint: requests to this route will be delegated to the endpoint.  The Arachne ID of the endpoint itself. This is a reference to the handler endpoint we declared above.   In general, this is how an Arachne applications always define their routing structure: A  server  DSL form, with nested forms for all the endpoints inside.  Again, it cannot be emphasized enough: these DSL forms do not create an actual Pedestal server. They create entities in the config that define the server. No server is actually started, and no ports will be opened until we use this config to initialize a runtime and call  start .  There's just one more step: we need to tell Arachne that this HTTP server is part of our runtime, and should be started when the runtime starts. Replace the existing  a/runtime  call with:  (a/runtime :myproj/runtime [:myproj/server])  At this point, your full configuration script should look something like this:  (require '[arachne.core.dsl :as a])\n(require '[arachne.http.dsl :as h])\n(require '[arachne.pedestal.dsl :as p])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/server])\n\n(h/handler :myproj/hello 'myproj.core/hello-handler)\n\n(p/server :myproj/server 8080\n\n  (h/endpoint :get  /  :myproj/hello)\n\n  )", 
            "title": "Server configuraton"
        }, 
        {
            "location": "/tutorials/http-requests/#running-the-server", 
            "text": "At this point, we can start a runtime. But before we do, we should configure Logback to log a little bit less verbosely. If no  logback.xml  file is supplied, the default log level is  DEBUG , and Pedestal dumps a  lot  of debug messages. Copy and paste the following  logback.xml  file into your  resources  directory to set a default log level of  INFO  and cut down on the noise:  configuration debug= false \n\n    - appender name= STDOUT  class= ch.qos.logback.core.ConsoleAppender \n         encoder \n             pattern %d{HH:mm:ss.SSS} %-5level - %logger{36} %msg%n /pattern \n         /encoder \n     /appender \n\n     root level= INFO \n       appender-ref ref= STDOUT / \n     /root  /configuration   Then, once logging is set up, we can run the server. Here, we'll use the command line (for simplicity), though of course you could use a REPL as described in the  creating a project  tutorial.  lein run :myproj/app :myproj/runtime  You should see log output indicating that the server has started.  Hit the  http://localhost:8080/  URL to see your endpoint in action!", 
            "title": "Running the server"
        }, 
        {
            "location": "/tutorials/http-requests/#path-params", 
            "text": "You aren't limited to specific, hardcoded routes. Arachne (via Pedestal) also allows you to use a semicolon in a route name to create a  path parameter . Values at that path are then available in the request, in a map under the  :path-params  key.  Let's try it out with a new handler function:  (defn greeter\n  [req]\n  (let [name (get-in req [:path-params :name])]\n    {:status 200\n     :body (if (empty? name)\n              Who's there!? \n             (str  Hello,   name  ! ))}))  And the corresponding line in the configuration script, inside our server:  (h/endpoint :get  /greet/:name  (h/handler 'myproj.core/greeter))  The  :name  key in the path indicates that any value at that URL should be bound to the  :name  key in the request's  :path-params .  You may also notice that we've defined the endpoint in a different way than we did before. Instead of giving the handler component an Arachne ID and then referencing it by ID, we defined it anonymously and inline, declaring it  inside  the  h/endpoint  form.  That works fine! Arachne DSL functions which define components (including  arachne.core.dsl/component ,  arachne.http.dsl/handler  and  arachne.pedestal.dsl/server , that we've seen so far) all return the entity ID of their newly created config entity, in the context configuration. And DSL forms which reference another component (such as  arachne.http.dsl/endpoint ) can accept either an Arachne ID,  or  an entity ID as a component identifier.  This means that the following three forms are equivalent:  (h/endpoint :get  /greet/:name  (h/handler 'myproj.core/greeter))  (def handler-eid (h/handler 'myproj.core/greeter))\n(h/endpoint :get  /greet/:name  handler-eid)  (h/handler :myproj/greeter 'myproj.core/greeter)\n(h/endpoint :get  /greet/:name  :myproj/greeter)  And, of course, we could both define a handler inline  and  give it an Arachne ID:  (h/endpoint :get  /greet/:name  (h/handler :myproj/greeter 'myproj.core/greeter))  You can use whichever of these variations leads to the cleanest and most readable config scripts.  Do note, though, that if you don't give a component an Arachne ID, and you don't capture the return value of the DSL function, you've just created a component entity that you have no ability to refer to, which will be pretty useless to you.", 
            "title": "Path params"
        }, 
        {
            "location": "/tutorials/http-requests/#components-and-the-runtime", 
            "text": "If you were looking for it, you might also have noticed that we're not getting the \"Hello World\" message from our Widget component, which we built in the last tutorial. That's because when we edited our  (a/runtime)  form to include  :myproj/server  instead of  :myproj/widget-1 , we removed all references to the widget from the components we told Arachne to start. Because nothing was depending on it, it was neither instantiated nor started with the rest of the System.  If we did want to have our custom component to start up, we can add it to the runtime, along with our HTTP server, like so:  (a/runtime :myproj/runtime [:myproj/server :myproj/widget-1])  Now, our custom component will start up alongside the server itself.  For much more on components and component dependencies, see the next tutorial on  dependency injection .", 
            "title": "Components and the runtime"
        }, 
        {
            "location": "/tutorials/dependency-injection/", 
            "text": "Components and Dependency Injection\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/tutorials/dependency-injection/#components-and-dependency-injection", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Components and Dependency Injection"
        }, 
        {
            "location": "/tutorials/serving-assets/", 
            "text": "Serving Static Assets\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Static Assets"
        }, 
        {
            "location": "/tutorials/serving-assets/#serving-static-assets", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Serving Static Assets"
        }, 
        {
            "location": "/tutorials/interceptors/", 
            "text": "Using Interceptors\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Request Interceptors"
        }, 
        {
            "location": "/tutorials/interceptors/#using-interceptors", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Using Interceptors"
        }, 
        {
            "location": "/tutorials/cljs/", 
            "text": "Building \n Serving ClojureScript\n\n\nTodo: write me", 
            "title": "ClojureSript"
        }, 
        {
            "location": "/tutorials/cljs/#building-serving-clojurescript", 
            "text": "Todo: write me", 
            "title": "Building &amp; Serving ClojureScript"
        }, 
        {
            "location": "/tutorials/figwheel/", 
            "text": "Dynamic Development with Figwheel\n\n\nThe code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Figwheel"
        }, 
        {
            "location": "/tutorials/figwheel/#dynamic-development-with-figwheel", 
            "text": "The code for this is ready to use, we're just waiting on the documentation. Coming soon!", 
            "title": "Dynamic Development with Figwheel"
        }, 
        {
            "location": "/modules/arachne-core/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-core"
        }, 
        {
            "location": "/modules/arachne-core/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-core/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-http/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-http"
        }, 
        {
            "location": "/modules/arachne-http/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-http/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-pedestal/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-pedestal"
        }, 
        {
            "location": "/modules/arachne-pedestal/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-pedestal/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-assets/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-assets"
        }, 
        {
            "location": "/modules/arachne-assets/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-assets/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-cljs/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-cljs"
        }, 
        {
            "location": "/modules/arachne-cljs/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-cljs/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne-figwheel/", 
            "text": "Concepts\n\n\nDocumentation coming soon\n\n\nConfiguration\n\n\nDocumentation coming soon", 
            "title": "arachne-figwheel"
        }, 
        {
            "location": "/modules/arachne-figwheel/#concepts", 
            "text": "Documentation coming soon", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne-figwheel/#configuration", 
            "text": "Documentation coming soon", 
            "title": "Configuration"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributor's Guide\n\n\nComing soon!", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributors-guide", 
            "text": "Coming soon!", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/api/", 
            "text": "placeholder, API docs will be generated on top of this", 
            "title": "API Documentation"
        }
    ]
}