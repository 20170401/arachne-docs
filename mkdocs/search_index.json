{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Arachne's documentation site! Here you will find everything you need to start using Arachne, as well as reference and API documentation.\n\n\nGetting Started\n\n\n\nIf you're just getting started, you'll probably want to try out the tutorials.\n\n\nThese will walk you through the process of creating a new Arachne application, introducing the essential concepts and code along the way.\n\n\n\n\ncreating a new project\n\n\nhandling HTTP requests\n\n\nusing dependency injection\n\n\nserving static assets\n\n\nusing request interceptors\n\n\ncompiling ClojureScript\n\n\ndynamic ClojureScript development with Figwheel\n\n\n\n\nArchitectural Overview\n\n\n\nSee the \noverview\n for a high-level view of Arachne's architecture, and an explanation of how all the pieces fit together.\n\n\nModules\n\n\n\nArachne isn't a monolithic project; it is composed of many small modules, each designed to offer a vertically-integrated set of functionality.\n\n\nAll Arachne applications are built by assembling a selection of suitable modules, both from \"official\" modules and third-party modules. In fact, all Arachne projects are \nthemselves\n modules and can be required by other Arachne projects.\n\n\nArachne's core modules include:\n\n\n\n\narachne.core\n - boostrap Arachne itself\n\n\narachne.http\n - definitions and tools for dealing with basic web concepts\n\n\narachne.pedestal\n - a Pedestal-based HTTP server\n\n\narachne.assets\n - generic asset transformation pipeline\n\n\narachne.cljs\n - tools to compile ClojureScript (as part of an asset pipeline)\n\n\narachne.figwheel\n - Figwheel server for rapid, iterative ClojureScript development\n\n\n\n\nVisit these module's documentation pages for a detailed explanation of the concepts that they define, and how to use them in the context of a project.\n\n\nContributing\n\n\n\nAlthough we're still in an early alpha phase, contributions are welcome! Please see our \nContributing Guide\n to see how you can get involved.", 
            "title": "Home"
        }, 
        {
            "location": "/architecture/", 
            "text": "Configuration\n\n\nArachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.\n\n\nEvery Arachne application is defined, first and foremost, by its \nconfiguration\n. The configuration defines every aspect of the application. This includes not only thinks that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:\n\n\n\n\nDependency injection\n\n\nHTTP Routes and endpoints\n\n\nDatabase migrations\n\n\nAsset processing\n\n\nAnything else that can possibly be represented as data.\n\n\n\n\nBecause the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory \nDatomic\n (or \nDataScript\n) database.\n\n\nSchema\n\n\nConfigurations have a schema, which is assembled from the schema of the included \nmodules\n. This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust \nentity type\n model inspired by ontology definition languages such as \nOWL\n.\n\n\nThe configuration schema is intended to define the \nconcepts\n that can exist in an application, and the possible relationships between them.\n\n\nSo, while an Arachne configuration database describes a particular application in great detail, the configuration \nschema\n defines the set of \npossible\n applications for a given set of modules, and the choices that are available to application authors.\n\n\nConfig Initialization\n\n\nWhile a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.\n\n\nIn order to fulfill its goal of being easy to use, Arachne provides a \nconfiguration DSL\n that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these \nconfiguration scripts\n are a small Clojure program that writes the configuration, and the configuration is handed over to the \nruntime\n to be started once it is complete.\n\n\nRuntime\n\n\nA configuration is just data in a database. It doesn't actually \ndo\n anything until it is used to initialize an Arachne runtime.\n\n\nConfiguration databases contain \ncomponent\n entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:\n\n\n\n\nRefs to other component entities (their \ndependencies\n)\n\n\nThe fully-qualified name of a Clojure function that can be called to obtain an instance of the component.\n\n\n\n\nWhen the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.\n\n\nComponents may be of any type, although it is required that they support Clojure's \nclojure.lang.IPersistentMap\n protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by \nassoc\ning a keyword.\n\n\nComponent objects may also satisfy the \ncom.stuartsierra.Lifecycle\n protocol from Stuart Sierra's \"Component\" library), implementing \nstart\n and \nstop\n methods that will be called when the system is started and stopped, respectively.\n\n\nFinally, the runtime wires each component together with its dependencies, and calls \nstart\n on each of them in dependency order. At this point, the full Arachne system is running.\n\n\nNote that an Arachne runtime is based off a single configuration \nvalue\n. The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.\n\n\nModules\n\n\nArachne is not a monolithic library. Any Arachne application is built from many different \nmodules\n, each implementing some feature set or providing some particular functionality. Some modules, such as the base \narachne.core\n or \narachne.http\n are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.\n\n\nAt a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.\n\n\nThe distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an \narachne.edn\n file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.\n\n\nModules may declare dependencies on other modules, and an Arachne \napplication\n may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.\n\n\nModules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:\n\n\n\n\nschema\n: Each active module provides some configuration \nschema\n, defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.\n\n\ninitializers\n: When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.\n\n\nconfigure\n: Each module also has the opportunity to query and update the configuration, \nafter\n modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.\n\n\n\n\nIn addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.\n\n\nApplications\n\n\nAn Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.\n\n\nThe API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative \narachne.edn\n file in the same way that it is for modules.\n\n\nStartup Sequence\n\n\nBased on the above description of \nmodules\n and the \nruntime\n, the complete initialization and startup sequence for a specific Arachne application is as follows:\n\n\n\n\n\n\nBuilding the configuration\n\n\n\n\nA graph of active modules is determined, starting with the application and its dependencies.\n\n\nA schema is assembled by asking each active module if it has any schema to contribute (via its \nschema\n hook). A fresh configuration is built, with a schema that is the union of the active module schemas.\n\n\nIn dependency order, each module has the opportunity to update the fresh configuration using its \ninitializers\n hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.\n\n\nIn reverse dependency order, each module has the opportunity to query and update the configuration using its \nconfigure\n hook. The application will go first, and the module with the fewest dependencies (which will always be \narachne.core\n), last.\n\n\n\n\n\n\n\n\nInitializing the runtime\n\n\nThe configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.\n\n\n\n\n\n\n\nStarting the runtime\n\n\nEach component object will have it's \ncom.stuartsierra.component/start\n method called, in dependency order, after having all its own dependencies \nassoc\ned on.", 
            "title": "Architectural Overview"
        }, 
        {
            "location": "/architecture/#configuration", 
            "text": "Arachne is fundamentally data driven, and Arachne's architecture may be viewed as an experiment in taking a \"data-driven\" approach to its logical extreme.  Every Arachne application is defined, first and foremost, by its  configuration . The configuration defines every aspect of the application. This includes not only thinks that are traditionally \"config\" values like URLs, ports and connection info, but also much more fundamental aspects of the application including:   Dependency injection  HTTP Routes and endpoints  Database migrations  Asset processing  Anything else that can possibly be represented as data.   Because the configuration is so central to an Arachne app, it needs to be both easy and powerful to query and manipulate. To this end, the configuration is implemented as a full featured, in-memory  Datomic  (or  DataScript ) database.", 
            "title": "Configuration"
        }, 
        {
            "location": "/architecture/#schema", 
            "text": "Configurations have a schema, which is assembled from the schema of the included  modules . This schema is Datomic schema, enhanced with additional meta-attributes to provide a robust  entity type  model inspired by ontology definition languages such as  OWL .  The configuration schema is intended to define the  concepts  that can exist in an application, and the possible relationships between them.  So, while an Arachne configuration database describes a particular application in great detail, the configuration  schema  defines the set of  possible  applications for a given set of modules, and the choices that are available to application authors.", 
            "title": "Schema"
        }, 
        {
            "location": "/architecture/#config-initialization", 
            "text": "While a Datomic database is very powerful and has a great many virtues, being readable in its raw form is not one of them. Transaction data for complex entity structures is verbose and not very human friendly.  In order to fulfill its goal of being easy to use, Arachne provides a  configuration DSL  that allows users to write simple, idiomatic Clojure forms that incrementaly build an application configuration. In essence, these  configuration scripts  are a small Clojure program that writes the configuration, and the configuration is handed over to the  runtime  to be started once it is complete.", 
            "title": "Config Initialization"
        }, 
        {
            "location": "/architecture/#runtime", 
            "text": "A configuration is just data in a database. It doesn't actually  do  anything until it is used to initialize an Arachne runtime.  Configuration databases contain  component  entities. Component entities are database entities that correspond with actual software objects in a running application. Component entities define two important pieces of information:   Refs to other component entities (their  dependencies )  The fully-qualified name of a Clojure function that can be called to obtain an instance of the component.   When the runtime is started, it searches for all the component entities in the configuration, and builds a dependency graph. It then calls each component's constructor function to obtain an actual instance.  Components may be of any type, although it is required that they support Clojure's  clojure.lang.IPersistentMap  protocol (i.e, be a map or a record) if they are to have any dependencies, since dependencies are added by  assoc ing a keyword.  Component objects may also satisfy the  com.stuartsierra.Lifecycle  protocol from Stuart Sierra's \"Component\" library), implementing  start  and  stop  methods that will be called when the system is started and stopped, respectively.  Finally, the runtime wires each component together with its dependencies, and calls  start  on each of them in dependency order. At this point, the full Arachne system is running.  Note that an Arachne runtime is based off a single configuration  value . The configuration itself is immutable at that point. If the configuration needs to be changed, then a new runtime needs to be constructed.", 
            "title": "Runtime"
        }, 
        {
            "location": "/architecture/#modules", 
            "text": "Arachne is not a monolithic library. Any Arachne application is built from many different  modules , each implementing some feature set or providing some particular functionality. Some modules, such as the base  arachne.core  or  arachne.http  are \"official\" modules and integral to the Arachne system; however, the hope is that Arachne will also develop a thriving ecosystem of third-party and open-source modules.  At a concrete level, an Arachne module is a Maven artifact containing Clojure code (or AOT compiled class files), packaged and delivered like any other. Modules can contain library code that users may call, just like any other Clojure library.  The distinguishing feature of an Arachne module compared to any other Clojure library is that each module JAR has an  arachne.edn  file at the root of the classpath, containing metadata about the module, its dependencies and its hooks into the Arachne system.  Modules may declare dependencies on other modules, and an Arachne  application  may depend on any number of modules. Only modules that are directly or transitively required by a given application are considered to be \"active\"; merely being present on the classpath is not sufficient to cause a module to be active in a given system.  Modules have hooks that allow active modules to participate in an Arachne system in a variety of ways. Specifically, these hooks are:   schema : Each active module provides some configuration  schema , defining the concepts, entity types and data that it exposes or expects to be present in the configuration. Modules may reference entities or attributes defined in the schema of modules that they depend upon.  initializers : When creating a configuration, after the schema is installed, each module has an opportunity to transact some initial data to the configuration. Module initializers are applied in dependency order: that is, the initializers of required modules are applied before the initalizers of the modules that depend upon them.  configure : Each module also has the opportunity to query and update the configuration,  after  modules that depend upon it have been initialized and configured. Module configuration is applied in reverse dependency order.   In addition, modules usually provide a library of DSL forms that make it easier to create and manipulate the configuration entities that they define in their schema.", 
            "title": "Modules"
        }, 
        {
            "location": "/architecture/#applications", 
            "text": "An Arachne application is just a special case of an Arachne module, where the module initializer is (usually) a user-supplied configuration script.  The API for initializing a new Arachne config requires users to specify the name of an Arachne application, which will be discovered in a classpath-relative  arachne.edn  file in the same way that it is for modules.", 
            "title": "Applications"
        }, 
        {
            "location": "/architecture/#startup-sequence", 
            "text": "Based on the above description of  modules  and the  runtime , the complete initialization and startup sequence for a specific Arachne application is as follows:    Building the configuration   A graph of active modules is determined, starting with the application and its dependencies.  A schema is assembled by asking each active module if it has any schema to contribute (via its  schema  hook). A fresh configuration is built, with a schema that is the union of the active module schemas.  In dependency order, each module has the opportunity to update the fresh configuration using its  initializers  hook. The application itself will have its initializers (including any user-supplied DSL scripts) called last.  In reverse dependency order, each module has the opportunity to query and update the configuration using its  configure  hook. The application will go first, and the module with the fewest dependencies (which will always be  arachne.core ), last.     Initializing the runtime  The configuration is passed to the runtime initializer function, which will instantiate all the components by calling their constructors.    Starting the runtime  Each component object will have it's  com.stuartsierra.component/start  method called, in dependency order, after having all its own dependencies  assoc ed on.", 
            "title": "Startup Sequence"
        }, 
        {
            "location": "/tutorials/creating-a-project/", 
            "text": "Creating an Arachne Project\n\n\n\nThis in-depth tutorial describes how to create a simple Arachne project from scratch, explaining everything as it goes. You can find the complete source code used in this tutorial on \nGithub\n.\n\n\n\nIn practice, you will probably want to start new Arachne projects by cloning an existing template app. However, when learning Arachne, it is instructive to go through this excercise and create each part piece by piece, to gain an understanding of what the parts are and how they work together.\n\n\n\n\nTo make the most of this particular tutorial, you will be most effective if you already:\n\n\n\n\nHave a basic knowledge of the Clojure language\n\n\nAre comfortable with Clojure protocols and records\n\n\nHave a Clojure editing environment that you are happy with. You should be able to launch a REPL, create Clojure source files, and evaluate forms from your source files in your REPL.\n\n\n\n\nCreating the project\n\n\nFor this tutorial, we'll use \nleiningen\n to assemble our dependencies and launch a JVM.\n\n\n\nOf course, you can also use Arachne with \nboot\n or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.\n\n\n\n\nFirst, let's create a new lein project. At the command line, navigate to a directory of your choice and type \nlein new myproj\n. This will create a directory called \nmyproj\n containing a \nproject.clj\n file and several stubbed source and test files.\n\n\nFor this tutorial, we will not be using the \n/test\n, \n/doc\n, \nREADME.md\n, \nLICENSE\n or \nCHANGELOG.md\n files, so we will delete them to keep things crystal clear.\n\n\nAfter this step, your directory structure should be as follows:\n\n\nmyproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nEdit the \nproject.clj\n file to contain the following contents:\n\n\n(defproject myproj \n0.1.0-SNAPSHOT\n\n  :dependencies [[org.clojure/clojure \n1.9.0-alpha14\n]\n                 [org.arachne-framework/arachne-core \n0.1.0-master-0081-0ab2073\n]\n                 [datascript \n0.15.5\n]\n                 [ch.qos.logback/logback-classic \n1.1.3\n]]\n  :repositories [[\narachne-dev\n\n                  \nhttp://maven.arachne-framework.org/artifactory/arachne-dev\n]])\n\n\n\n\nYou can just cut and paste for now, but if you're curious about what any of this means:\n\n\n\n\nArachne leverages the new \nclojure.spec\n library heavily, and therefore requires the latest alpha of Clojure 1.9\n\n\nThe version number for Arachne looks funky. WTF is \n0.1.0-master-0081-0ab2073\n supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format: \nsemver\n-\nbranch\n-\ncommit-idx\n-\ncommit-sha\n. This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that \n0081\n is newere than \n0080\n and older than \n0082\n. Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date.\n\n\nWe've included DataScript on the classpath, but we also could have used \nDatomic\n or \nDatomic Free\n. Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)\n\n\nLogging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.\n\n\nWe need to add the \narachne-dev\n repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.\n\n\n\n\nWriting a component\n\n\nArachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines a the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on \ndependency injection\n.\n\n\nTo get started with the simplest possible Arachne application, we need to do two things:\n\n\n\n\nCreate a SierraComponent that our system will use\n\n\nDefine a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)\n\n\n\n\nFirst, let's pop open \nsrc/myproj/core.clj\n and define a component (after requiring a couple namespaces):\n\n\n(ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg \nHello, world!\n)\n    this)\n  (stop [this]\n    (log/info :msg \nGoodnight!\n)\n    this))\n\n\n\n\nThis is pretty straightforward; this code simply defines a component that satisfies Component's \nLifecycle\n protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.\n\n\nIf you want, at this point, you can verify that your component is working as expected using the REPL:\n\n\n(def w (-\nWidget))\n;;=\n #'myproj.core/w\n(c/start w)\n;;=\n #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nNow, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:\n\n\n(defn make-widget\n  \nConstructor for a Widget\n\n  []\n  (-\nWidget))\n\n\n\n\nGreat! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.\n\n\nWriting a configuration script\n\n\nWhat is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.\n\n\nBut, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be \nsuper\n readable.\n\n\nSo Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a \nconfig script\n, and when the config script is executed, it will populate the config database with everything it needs.\n\n\nSo what does a config script look like? For our very simple app, it looks like this:\n\n\n(require '[arachne.core.dsl :as a])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/widget-1])\n\n\n\n\nSave this to a file called \nconfig/myproj.clj\n in your project directory.\n\n\nThere are two things worth unpacking here, before we dive into what these forms mean.\n\n\nFirst, you will notice that the file has no namespace. That is fully intentional. It is \nnot part of your project's codebase\n. It is a config script. No code should require it. It's not in your \n/src\n directory, so it isn't even on the classpath!\n\n\nIn a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your \nreal\n application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.\n\n\nSecond, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there \nis\n no current configuration, and so trying to call a DSL form will throw an error.\n\n\nWith that out of the way, let's talk about what these functions do.\n\n\nThe \narachne.core.dsl/component\n function defines a component, in the configuration. The first argument (here the keyword \n:myproj/widget-1\n) is a unique ID for our component. Anywhere in our config where we refer to \n:myproj/widget-1\n, we're talking about the same entity in the configuration DB.\n\n\nThe second argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only \nidentifies\n the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.\n\n\nThe \narachne.core.dsl/component\n function also takes an optional third argument, to specify the dependencies of the component, but we'll ignore that for now.\n\n\nThe \narachne.core.dsl/runtime\n function defines a named \nruntime entity\n in the application's configuration. The runtime entity groups components together and specifies which ones should be instanted when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.\n\n\nIn this case we just have one runtime (named \n:myproj/runtime\n), which identifies our one and only component (\n:myproj/widget-1\n). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.\n\n\nApplication metadata\n\n\nFinally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.\n\n\nTo do this, we need write an \narachne.edn\n file, somewhere on our classpath, that contains this information. Let's put it in \n/resources\n for now:\n\n\n[{:arachne/name :myproj/app\n  :arachne/inits [\nconfig/myproj.clj\n]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]\n\n\n\n\n\n\n:arachne/name\n is just the name of our application as a whole.\n\n\n:arachne/inits\n is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the process-relative filename of the config script that we wrote in the previous section.\n\n\n:arachne/dependencies\n specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named \n:org.arachne-framework/arachne-core\n. All the modules we want to use must also be on the classpath (that is, specified in our \nproject.clj\n, which \narachne.core\n is.)\n\n\n\n\nThat's it! Our Arachne application is now ready to run.\n\n\nAt this point, your project directory structure should look like this:\n\n\nmyproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj\n\n\n\n\nRunning the application\n\n\nThere are two ways to run an Arachne application:\n\n\n\n\nFrom the REPL, as you would during development\n\n\nFrom the command line, as you might in production\n\n\n\n\nRunning from the REPL\n\n\nWith a REPL open, start by requiring the namespaces we'll need to get things rolling:\n\n\n(require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])\n\n\n\n\nThen, we can build a configuration value:\n\n\n(def cfg (arachne/config :myproj/app))\n;; =\n #'user/cfg\n\n\n\n\nInside this seemingly simple function call, a \nhuge\n number of things are happening under the hood.\n\n\n\n\nWe pass in only the name of our application, \n:myproj/app\n\n\nThe application metadata is loaded from the \narachne.edn\n file.\n\n\nA new config is built, using schema derived from all the modules that we depend on.\n\n\nOur config script is evaluated (you can put some \nprintlns\n in it, if you like, to prove to yourself that this is the case)\n\n\nAll the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.\n\n\n\n\nThe value that is returned is a configuration object: an immutable, in-memory database.\n\n\nSo far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:\n\n\n(def rt (arachne/runtime cfg :myproj/runtime))\n;; =\n #'user/rt\n\n\n\n\nWhat just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.\n\n\nAll of our constructor functions have been called (try putting a \nprintln\n in the constructor function to convince yourself that this is true), but we haven't yet called Component's \nstart\n method on our system, so nothing's actually happened yet. '\n\n\nLet's run it!\n\n\n(def started-rt (c/start rt))\n=\n #'user/started-rt\n\n\n\n\nNote that it's important to capture the result of calling \nstart\n; we'll need it to pass to \nstop\n if we ever want to stop our system.\n\n\nIn our console, we should also see two log messages:\n\n\n22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nOne is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.\n\n\nYou can call \nstop\n on the runtime when you're done:\n\n\n(c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg \nStopping Arachne runtime\n, :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg \nGoodnight!\n, :line nil}\n\n\n\n\nThere are a few gotchas to remember when doing REPL-driven development with Arachne:\n\n\n\n\nIf you change anything in your config script, you'll need to stop your runtime and rebuild your config from \n(arachne.core/config)\n. The config that it returns is immutable, and can't be updated once it's been used to start a runtime.\n\n\nIf you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from \n(arachne.core/runtime)\n. Changing the definition of a component won't change the instances that are referenced inside the runtime object.\n\n\n\n\nIn the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things manually, but for now it's the responsibility of users to keep track of them.\n\n\nRunning from the command line\n\n\nRunning from the command line is, fortunately, even more straightforward. Arachne defines an \narachne.run\n namespace, which contains a \n-main\n method that can be used to easily launch an Arachne application.\n\n\nYou can set \narachne.run\n as the default \n:main\n namespace in leiningen by adding the following key to your \nproject.clj\n:\n\n\n:main arachne.run\n\n\n\n\nThen, you can start your Arachne application from the command line by calling \nlein run\n and passing it two arguments: the name of your application as defined in \narachne.edn\n, and the name of the runtime you want to start as defined in your init script:\n\n\nlein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg \nLaunching Arachne application\n, :name \n:myproj/app\n, :runtime \n:myproj/runtime\n, :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg \nStarting Arachne runtime\n, :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg \nHello, world!\n, :line nil}\n\n\n\n\nYou should see the same log messages, indicating that the application (including your component) has started correctly.\n\n\nYou will need to terminate the program manually when you're done, since it won't exit by itself.\n\n\nError reporting\n\n\nThere is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.\n\n\nTo see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:\n\n\n(a/component :widget-1 'myproj.core/make-widget)\n\n\n\n\nWhen we try to build a config based on this script, it throws an exception:\n\n\n(def cfg (arachne/config :myproj/app))\n;; CompilerException arachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n\n\n\n\nThis should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...\n\n\n(.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3657)\n    at clojure.lang.Compiler$DefExpr.eval(Compiler.java:451)\n    at clojure.lang.Compiler.eval(Compiler.java:6983)\n\n\nSNIP MANY MANY LINES\n\n\n    at arachne.core.module$initialize$fn__5505.invoke(module.clj:161)\n    ... 48 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/component` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$component.invokeStatic(dsl.clj:57)\n    at arachne.core.dsl$component.doInvoke(dsl.clj:57)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invokeStatic(myproj.clj:3)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invoke(myproj.clj:3)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 56 more\n\n\n\n\nIf you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to \narachne.core.dsl/component\n. Fine.\n\n\nFortunately, with Arachne, there is a slightly better alternative: invoke \n(arachne.error/explain)\n, with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the onecurrently bound to \n*e\n, in Clojure's REPL).\n\n\nThe output of \nexplain\n is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:\n\n\n\n\nHopefully, you find this to be a better alternative.\n\n\nOne of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Creating a Project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#creating-the-project", 
            "text": "For this tutorial, we'll use  leiningen  to assemble our dependencies and launch a JVM.  \nOf course, you can also use Arachne with  boot  or any other Clojure build tool. We simply use lein for this tutorial since it's the most familiar to the most people.  First, let's create a new lein project. At the command line, navigate to a directory of your choice and type  lein new myproj . This will create a directory called  myproj  containing a  project.clj  file and several stubbed source and test files.  For this tutorial, we will not be using the  /test ,  /doc ,  README.md ,  LICENSE  or  CHANGELOG.md  files, so we will delete them to keep things crystal clear.  After this step, your directory structure should be as follows:  myproj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj  Edit the  project.clj  file to contain the following contents:  (defproject myproj  0.1.0-SNAPSHOT \n  :dependencies [[org.clojure/clojure  1.9.0-alpha14 ]\n                 [org.arachne-framework/arachne-core  0.1.0-master-0081-0ab2073 ]\n                 [datascript  0.15.5 ]\n                 [ch.qos.logback/logback-classic  1.1.3 ]]\n  :repositories [[ arachne-dev \n                   http://maven.arachne-framework.org/artifactory/arachne-dev ]])  You can just cut and paste for now, but if you're curious about what any of this means:   Arachne leverages the new  clojure.spec  library heavily, and therefore requires the latest alpha of Clojure 1.9  The version number for Arachne looks funky. WTF is  0.1.0-master-0081-0ab2073  supposed to mean? Well, instead of using SNAPSHOT builds that are effectively mutable and can change underneath you, Arachne's dev builds are named with the following format:  semver - branch - commit-idx - commit-sha . This guarantees that there is a unique version number for each dev build, and you can compare any two versions by looking at the commit-idx: we know that  0081  is newere than  0080  and older than  0082 . Eventually, we'll move to regular release versions, but for now working with dev builds is the best way to stay up-to-date.  We've included DataScript on the classpath, but we also could have used  Datomic  or  Datomic Free . Arachne will detect which one is on your classpath and use whatever is present (there is also a way to specify explicitly which to use, if your project includes both Datomic and Datascript.)  Logging is provided by SLF4J, which is compatible with the logging used by most Clojure products (such as Datomic itself.) We can use any concrete logger that supports SLF4J. Logback is merely a common choice.  We need to add the  arachne-dev  repository explicitly, since Arachne is not yet deployed into Clojars or any other public maven repository.", 
            "title": "Creating the project"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-component", 
            "text": "Arachne uses Stuart Sierra's \"Component\" library as the foundation of its runtime system. Component defines a the concept of a \"component\" (often called a \"SierraComponent\"), which is a (possibly stateful) object that can be started and stopped, as part of a larger system. SierraComponents can also have dependencies on eachother: more on that in the tutorial on  dependency injection .  To get started with the simplest possible Arachne application, we need to do two things:   Create a SierraComponent that our system will use  Define a function which, when called, will return an instance of our component (a \"constructor\" function, in Arachne parlance)   First, let's pop open  src/myproj/core.clj  and define a component (after requiring a couple namespaces):  (ns myproj.core\n  (:require [com.stuartsierra.component :as c]\n            [arachne.log :as log]))\n\n(defrecord Widget []\n  c/Lifecycle\n  (start [this]\n    (log/info :msg  Hello, world! )\n    this)\n  (stop [this]\n    (log/info :msg  Goodnight! )\n    this))  This is pretty straightforward; this code simply defines a component that satisfies Component's  Lifecycle  protocol, and logs out a simple message when it is started and stopped, using Arachne's logging utility library.  If you want, at this point, you can verify that your component is working as expected using the REPL:  (def w (- Widget))\n;;=  #'myproj.core/w\n(c/start w)\n;;=  #myproj.core.Widget{}\n21:29:50.867 [nREPL-worker-5] INFO  myproj.core - {:msg  Hello, world! , :line nil}  Now, all that's left is to define a constructor that, when invoked, will return an (unstarted) instance of our SierraComponent, fresh and ready to use:  (defn make-widget\n   Constructor for a Widget \n  []\n  (- Widget))  Great! We're done here. Save the file and let's move on to the next step: creating an Arachne configuration.", 
            "title": "Writing a component"
        }, 
        {
            "location": "/tutorials/creating-a-project/#writing-a-configuration-script", 
            "text": "What is an Arachne configuration? Well, it's data that specifies everything about our application that can possibly be specified using data. And it's all in a database. Under the hood, our configuration is stored in a full-fledged, queryable Datomic (or DataScript) database, which makes it extremely powerful for modules to query and update under the hood.  But, building a configuration by directly creating a Datomic database is awkward. It isn't hard, but it's verbose, and not very readable. And since the configuration is what defines the basic structure of our application, we want it to be  super  readable.  So Arachne provides a DSL (domain specific language) oriented specifically towards writing configuration data. Instead of writing a database, you can just write a  config script , and when the config script is executed, it will populate the config database with everything it needs.  So what does a config script look like? For our very simple app, it looks like this:  (require '[arachne.core.dsl :as a])\n\n(a/component :myproj/widget-1 'myproj.core/make-widget)\n\n(a/runtime :myproj/runtime [:myproj/widget-1])  Save this to a file called  config/myproj.clj  in your project directory.  There are two things worth unpacking here, before we dive into what these forms mean.  First, you will notice that the file has no namespace. That is fully intentional. It is  not part of your project's codebase . It is a config script. No code should require it. It's not in your  /src  directory, so it isn't even on the classpath!  In a very real sense, your config script is an entirely separate mini-program that has only one job: generating a config. Your  real  application will read that config and execute an application based on it. We happen to be using the same JVM for both programs, here, and using an \"in memory\" only config, because it's convenient. But it's theoretically possible to evaluate a config script, store the resulting config in a persistent database, shut down your computer, and then hand the config to an application and have it run at some point in the distant future.  Second, you can't evaluate these forms at the REPL. Sorry. This is because each time one of these config DSL forms is evaluated, it updates the \"current configuration\" (stored in an atom in a dynamic var, if you're curious how that works.) If you're just in a regular old REPL, there  is  no current configuration, and so trying to call a DSL form will throw an error.  With that out of the way, let's talk about what these functions do.  The  arachne.core.dsl/component  function defines a component, in the configuration. The first argument (here the keyword  :myproj/widget-1 ) is a unique ID for our component. Anywhere in our config where we refer to  :myproj/widget-1 , we're talking about the same entity in the configuration DB.  The second argument is a quoted symbol, identifying the constructor function to use when actually creating the component instance. Understand, the config DSL function only  identifies  the constructor function; it isn't called yet! It's merely stored in the config, to be used when your app finally starts.  The  arachne.core.dsl/component  function also takes an optional third argument, to specify the dependencies of the component, but we'll ignore that for now.  The  arachne.core.dsl/runtime  function defines a named  runtime entity  in the application's configuration. The runtime entity groups components together and specifies which ones should be instanted when an Arachne program starts. When we actually run our program, we'll see that we have to tell Arachne which runtime we want to use, which in turn indicates the set of components that we want started.  In this case we just have one runtime (named  :myproj/runtime ), which identifies our one and only component ( :myproj/widget-1 ). But as applications get larger and more complex, it can be very useful to have multiple runtimes in the same config. For example, two different but related services could be defined in the same Arachne config, but have completely different runtimes, and do completely different things when started.", 
            "title": "Writing a configuration script"
        }, 
        {
            "location": "/tutorials/creating-a-project/#application-metadata", 
            "text": "Finally, we have to tell Arachne some metadata about our application: what its name is, what modules it depends on, and where our config script is located.  To do this, we need write an  arachne.edn  file, somewhere on our classpath, that contains this information. Let's put it in  /resources  for now:  [{:arachne/name :myproj/app\n  :arachne/inits [ config/myproj.clj ]\n  :arachne/dependencies [:org.arachne-framework/arachne-core]}]   :arachne/name  is just the name of our application as a whole.  :arachne/inits  is a vector of  \"initializers\" to use. Initializers come in many flavors (for example, you can pass in raw Datomic transactions to the config) but here, we're just going to give it the process-relative filename of the config script that we wrote in the previous section.  :arachne/dependencies  specifies the module names of the Arachne modules that we want to depend on. For this rudimentary example, that's just the core module, named  :org.arachne-framework/arachne-core . All the modules we want to use must also be on the classpath (that is, specified in our  project.clj , which  arachne.core  is.)   That's it! Our Arachne application is now ready to run.  At this point, your project directory structure should look like this:  myproj\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myproj.clj\n\u251c\u2500\u2500 project.clj\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 arachne.edn\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 myproj\n        \u2514\u2500\u2500 core.clj", 
            "title": "Application metadata"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-the-application", 
            "text": "There are two ways to run an Arachne application:   From the REPL, as you would during development  From the command line, as you might in production", 
            "title": "Running the application"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-repl", 
            "text": "With a REPL open, start by requiring the namespaces we'll need to get things rolling:  (require '[arachne.core :as arachne])\n(require '[com.stuartsierra.component :as c])  Then, we can build a configuration value:  (def cfg (arachne/config :myproj/app))\n;; =  #'user/cfg  Inside this seemingly simple function call, a  huge  number of things are happening under the hood.   We pass in only the name of our application,  :myproj/app  The application metadata is loaded from the  arachne.edn  file.  A new config is built, using schema derived from all the modules that we depend on.  Our config script is evaluated (you can put some  printlns  in it, if you like, to prove to yourself that this is the case)  All the modules that we required are doing their thing, adding their own data to the config, and possibly querying and manipulating the data that we added.   The value that is returned is a configuration object: an immutable, in-memory database.  So far, we haven't actually started anything yet. To do that, we initialize a runtime using the config we just built:  (def rt (arachne/runtime cfg :myproj/runtime))\n;; =  #'user/rt  What just happened? We gave the runtime initializer the configuration we want to use, and the Arachne ID of the runtime entity, within the config (remember)? What we got back was an initialized, but unstarted Arachne runtime object.  All of our constructor functions have been called (try putting a  println  in the constructor function to convince yourself that this is true), but we haven't yet called Component's  start  method on our system, so nothing's actually happened yet. '  Let's run it!  (def started-rt (c/start rt))\n=  #'user/started-rt  Note that it's important to capture the result of calling  start ; we'll need it to pass to  stop  if we ever want to stop our system.  In our console, we should also see two log messages:  22:27:18.671 [nREPL-worker-20] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:27:18.675 [nREPL-worker-20] INFO  myproj.core - {:msg  Hello, world! , :line nil}  One is the log message that Arachne spits out when it starts; the other is the log message from our component. It worked! We now have a full (if small) Arachne system running on our machine.  You can call  stop  on the runtime when you're done:  (c/stop started-rt)\n22:33:23.754 [nREPL-worker-21] INFO  arachne.core.runtime - {:msg  Stopping Arachne runtime , :line nil}\n22:33:23.754 [nREPL-worker-21] INFO  myproj.core - {:msg  Goodnight! , :line nil}  There are a few gotchas to remember when doing REPL-driven development with Arachne:   If you change anything in your config script, you'll need to stop your runtime and rebuild your config from  (arachne.core/config) . The config that it returns is immutable, and can't be updated once it's been used to start a runtime.  If you change the code you use to define your component definitions, you'll have to re-initialize your runtime to see the changes, starting from  (arachne.core/runtime) . Changing the definition of a component won't change the instances that are referenced inside the runtime object.   In the future, we plan to release dev tools that will watch source files and config scripts for changes and do some of these things manually, but for now it's the responsibility of users to keep track of them.", 
            "title": "Running from the REPL"
        }, 
        {
            "location": "/tutorials/creating-a-project/#running-from-the-command-line", 
            "text": "Running from the command line is, fortunately, even more straightforward. Arachne defines an  arachne.run  namespace, which contains a  -main  method that can be used to easily launch an Arachne application.  You can set  arachne.run  as the default  :main  namespace in leiningen by adding the following key to your  project.clj :  :main arachne.run  Then, you can start your Arachne application from the command line by calling  lein run  and passing it two arguments: the name of your application as defined in  arachne.edn , and the name of the runtime you want to start as defined in your init script:  lein run :myproj/app :myproj/runtime\n22:46:01.744 [main] INFO  arachne.run - {:msg  Launching Arachne application , :name  :myproj/app , :runtime  :myproj/runtime , :line nil}\n22:46:03.498 [main] INFO  arachne.core.runtime - {:msg  Starting Arachne runtime , :line nil}\n22:46:03.507 [main] INFO  myproj.core - {:msg  Hello, world! , :line nil}  You should see the same log messages, indicating that the application (including your component) has started correctly.  You will need to terminate the program manually when you're done, since it won't exit by itself.", 
            "title": "Running from the command line"
        }, 
        {
            "location": "/tutorials/creating-a-project/#error-reporting", 
            "text": "There is one final thing you should be aware of when developing an Arachne application: its enhanced error reporting tools.  To see what happens when something goes wrong, lets tweak our config script to pass an invalid name for our component: a keyword with no namespace:  (a/component :widget-1 'myproj.core/make-widget)  When we try to build a config based on this script, it throws an exception:  (def cfg (arachne/config :myproj/app))\n;; CompilerException arachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)  This should look quite familiar to anyone who has experience with Clojure development... in that it isn't very helpful. Of course we can obtain a bit more information with some digging...  (.printStackTrace *e)\n\narachne.ArachneException: Error initializing module `:myproj/app` (type = :arachne.core.module/error-in-initializer), compiling:(form-init8542683170413574929.clj:1:10)\n    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3657)\n    at clojure.lang.Compiler$DefExpr.eval(Compiler.java:451)\n    at clojure.lang.Compiler.eval(Compiler.java:6983) SNIP MANY MANY LINES \n\n    at arachne.core.module$initialize$fn__5505.invoke(module.clj:161)\n    ... 48 more\nCaused by: arachne.ArachneException: Arguments to `arachne.core.dsl/component` did not conform to registered spec (type = :arachne.error/invalid-args)\n    at arachne.error$arachne_ex.invokeStatic(error.clj:132)\n    at arachne.error$arachne_ex.invoke(error.clj:123)\n    at arachne.error$assert.invokeStatic(error.clj:60)\n    at arachne.error$assert.invoke(error.clj:53)\n    at arachne.error$assert_args.invokeStatic(error.clj:73)\n    at arachne.error$assert_args.doInvoke(error.clj:66)\n    at clojure.lang.RestFn.applyTo(RestFn.java:139)\n    at clojure.core$apply.invokeStatic(core.clj:659)\n    at clojure.core$apply.invoke(core.clj:652)\n    at arachne.core.dsl$component.invokeStatic(dsl.clj:57)\n    at arachne.core.dsl$component.doInvoke(dsl.clj:57)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invokeStatic(myproj.clj:3)\n    at arachne_init_script_8334492e_a146_4e04_98ec_e1f15e1976f1$eval10065.invoke(myproj.clj:3)\n    at clojure.lang.Compiler.eval(Compiler.java:6978)\n    at clojure.lang.Compiler.load(Compiler.java:7430)\n    ... 56 more  If you manage to read through all that, you might eventually discover something helpful: it looks like there was something wrong with the arguments to  arachne.core.dsl/component . Fine.  Fortunately, with Arachne, there is a slightly better alternative: invoke  (arachne.error/explain) , with no arguments, at the REPL. This will produce a pretty-printed view of the last top-level exception (the onecurrently bound to  *e , in Clojure's REPL).  The output of  explain  is still extremely verbose. It still lists the full stacktrace because, well, sometimes you need that. However, it is colored and highlighted in such a way that with a bit of scrolling you will eventually see something like this:   Hopefully, you find this to be a better alternative.  One of Arachne's goals is to provide good error messages, so if you find an error that is unhelpful or confusing, please consider it a bug and file an issue: we would love to get to a point where all error messages are not only clear and helpful, but illuminating on how the system as a whole is supposed to work.", 
            "title": "Error reporting"
        }, 
        {
            "location": "/tutorials/http-requests/", 
            "text": "Handling HTTP Requests\n\n\nTodo: write me", 
            "title": "Handling HTTP Requests"
        }, 
        {
            "location": "/tutorials/http-requests/#handling-http-requests", 
            "text": "Todo: write me", 
            "title": "Handling HTTP Requests"
        }, 
        {
            "location": "/tutorials/dependency-injection/", 
            "text": "Components and Dependency Injection\n\n\nTodo: write me", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/tutorials/dependency-injection/#components-and-dependency-injection", 
            "text": "Todo: write me", 
            "title": "Components and Dependency Injection"
        }, 
        {
            "location": "/tutorials/serving-assets/", 
            "text": "Serving Static Assets\n\n\nTodo: write me", 
            "title": "Static Assets"
        }, 
        {
            "location": "/tutorials/serving-assets/#serving-static-assets", 
            "text": "Todo: write me", 
            "title": "Serving Static Assets"
        }, 
        {
            "location": "/tutorials/interceptors/", 
            "text": "Using Interceptors\n\n\nTodo: write me", 
            "title": "Request Interceptors"
        }, 
        {
            "location": "/tutorials/interceptors/#using-interceptors", 
            "text": "Todo: write me", 
            "title": "Using Interceptors"
        }, 
        {
            "location": "/tutorials/cljs/", 
            "text": "Building \n Serving ClojureScript\n\n\nTodo: write me", 
            "title": "ClojureSript"
        }, 
        {
            "location": "/tutorials/cljs/#building-serving-clojurescript", 
            "text": "Todo: write me", 
            "title": "Building &amp; Serving ClojureScript"
        }, 
        {
            "location": "/tutorials/figwheel/", 
            "text": "Dynamic Development with Figwheel\n\n\nTodo: write me", 
            "title": "Figwheel"
        }, 
        {
            "location": "/tutorials/figwheel/#dynamic-development-with-figwheel", 
            "text": "Todo: write me", 
            "title": "Dynamic Development with Figwheel"
        }, 
        {
            "location": "/modules/arachne.core/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.core"
        }, 
        {
            "location": "/modules/arachne.core/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.core/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne.http/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.http"
        }, 
        {
            "location": "/modules/arachne.http/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.http/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne.pedestal/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.pedestal"
        }, 
        {
            "location": "/modules/arachne.pedestal/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.pedestal/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne.assets/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.assets"
        }, 
        {
            "location": "/modules/arachne.assets/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.assets/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne.cljs/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.cljs"
        }, 
        {
            "location": "/modules/arachne.cljs/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.cljs/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/arachne.figwheel/", 
            "text": "Concepts\n\n\nTodo: write me\n\n\nConfiguration\n\n\nTodo: write me", 
            "title": "arachne.figwheel"
        }, 
        {
            "location": "/modules/arachne.figwheel/#concepts", 
            "text": "Todo: write me", 
            "title": "Concepts"
        }, 
        {
            "location": "/modules/arachne.figwheel/#configuration", 
            "text": "Todo: write me", 
            "title": "Configuration"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributor's Guide\n\n\nComing soon", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributors-guide", 
            "text": "Coming soon", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/api/", 
            "text": "Arachne API Documentation \nhljs.initHighlightingOnLoad();\nGenerated by \nCodox\nArachne API Documentation\n \nProject\nIndex\nNamespaces\narachne.assets\narachne.assets.config\narachne.assets.dsl\narachne.assets.pipeline\narachne.assets.schema\narachne.assets.specs\narachne.assets.util\narachne.build\narachne.core\narachne.core.config\narachne.core.config.impl.common\narachne.core.config.impl.datascript\narachne.core.config.impl.datomic\narachne.core.config.impl.multiplex\narachne.core.config.model\narachne.core.config.model.specs\narachne.core.config.script\narachne.core.config.specs\narachne.core.config.validation\narachne.core.dsl\narachne.core.module\narachne.core.runtime\narachne.core.runtime.specs\narachne.core.schema\narachne.core.util\narachne.core.util.specs\narachne.core.validators\narachne.error\narachne.error.format\narachne.http\narachne.http.config\narachne.http.dsl\narachne.http.dsl.test\narachne.http.schema\narachne.http.validators\narachne.log\narachne.pedestal\narachne.pedestal.config\narachne.pedestal.dsl\narachne.pedestal.routes\narachne.pedestal.schema\narachne.pedestal.server\narachne.pedestal.specs\narachne.run\nArachne API Documentation\n \nGenerated API documentation for the Arachne web framework.\nNamespaces\narachne.assets\nPublic variables and functions:\n \nconfigure\n \n \nschema\n \narachne.assets.config\nPublic variables and functions:\n \nconfigure-input-dependencies\n \narachne.assets.dsl\nPublic variables and functions:\n \nhttp\n \n \ninput-dir\n \n \noutput-dir\n \n \npipeline\n \n \ntransducer\n \narachne.assets.pipeline\nPublic variables and functions:\n \nfs-chan-handler\n \n \nhttp-handler\n \n \ninput-channels\n \n \ninput-directory\n \n \nmerge-inputs\n \n \noutput-directory\n \n \nProducer\n \n \ntransducer\n \n \nTransformer\n \n \nwatch-dir\n \narachne.assets.schema\nPublic variables and functions:\n \nschema\n \narachne.assets.specs\nPublic variables and functions:\narachne.assets.util\nPublic variables and functions:\n \ndist\n \narachne.build\nApplication entry point for running an Arachne application\nPublic variables and functions:\n \n-main\n \narachne.core\nThe core Arachne module that bootstraps everything else\nPublic variables and functions:\n \nconfig\n \n \nruntime\n \narachne.core.config\nHandles building and managing Arachne's central Config object\nPublic variables and functions:\n \n*default-partition*\n \n \n*dsl-function*\n \n \n*provenance-txdata*\n \n \nattr\n \n \nConfiguration\n \n \ndependencies\n \n \ndependency-rules\n \n \ninit\n \n \npull\n \n \nq\n \n \nresolve-tempid\n \n \nstack-provenance-txdata\n \n \ntempid\n \n \ntempid-literal\n \n \nupdate\n \n \nwith-provenance\n \narachne.core.config.impl.common\nPublic variables and functions:\n \nwith\n \narachne.core.config.impl.datascript\nPublic variables and functions:\n \nnew\n \n \nreplace-idents\n \narachne.core.config.impl.datomic\nPublic variables and functions:\n \nnew\n \narachne.core.config.impl.multiplex\nPublic variables and functions:\n \nnew\n \narachne.core.config.model\nUtilities for creating a configuration schema using a richer data model.\nPublic variables and functions:\n \nattr\n \n \nrules\n \n \ntype\n \narachne.core.config.model.specs\nPublic variables and functions:\n \nshorthand-schema\n \narachne.core.config.script\nInitialziation \n script support for user configuration values.\nPublic variables and functions:\n \napply-initializer\n \n \ncontext-config\n \n \ndefdsl\n \n \ninit-script-ns?\n \n \nresolve-aid\n \n \ntransact\n \n \nupdate\n \narachne.core.config.specs\nPublic variables and functions:\n \nconfig?\n \n \ndate?\n \n \ntempid?\n \narachne.core.config.validation\nPublic variables and functions:\n \nadd-core-validators\n \n \nadd-validators\n \n \nvalidate\n \narachne.core.dsl\nUser-facing DSL for use in init scripts\nPublic variables and functions:\n \ncomponent\n \n \nref\n \n \nresolved-ref\n \n \nruntime\n \n \ntransact\n \narachne.core.module\nThe namespace used for defining and loading Arachne modules\nPublic variables and functions:\narachne.core.runtime\nDependency Injection and lifecycle management\nPublic variables and functions:\n \ninit\n \n \nlookup\n \n \nvalidate-and-start\n \narachne.core.runtime.specs\nPublic variables and functions:\n \nruntime?\n \narachne.core.schema\nPublic variables and functions:\n \nschema\n \narachne.core.util\nPublic variables and functions:\n \narity\n \n \nkeys**\n \n \nlazy-instance?\n \n \nlazy-satisfies?\n \n \nmap-transform\n \n \nmkeep\n \n \nread-edn\n \n \nrequire-and-resolve\n \narachne.core.util.specs\nPublic variables and functions:\narachne.core.validators\nPublic variables and functions:\n \nmax-cardinality\n \n \nmin-cardinality\n \narachne.error\nTools for creating, throwing, catching and printing useful error messages in\na standardized way. See ADR-13.\nPublic variables and functions:\n \n*default-explain-opts*\n \n \n*print-exception*\n \n \narachne-ex\n \n \nassert\n \n \nassert-args\n \n \nbullet-list\n \n \ndeferror\n \n \nerror\n \n \nerror-registry\n \n \nerror-type?\n \n \nexplain\n \n \nformat-date\n \n \nlog-error\n \n \nutc-date-format\n \n \nwrap-error\n \narachne.error.format\nPublic variables and functions:\n \n*format-err*\n \n \nformat\n \n \njustify\n \n \npprint-str-truncated\n \narachne.http\nPublic variables and functions:\n \nconfigure\n \n \nHandler\n \n \nhandler-component\n \n \nschema\n \narachne.http.config\nUtilities for working with HTTP entities in a configuration\nPublic variables and functions:\n \nadd-endpoint-dependencies\n \n \nendpoints\n \n \nfind-endpoints\n \n \ninfer-endpoint-names\n \n \nroute-path\n \n \nroute-rules\n \n \nroute-segments\n \n \nservers\n \narachne.http.dsl\nPublic variables and functions:\n \n*context-path*\n \n \n*context-server*\n \n \ncontext\n \n \nendpoint\n \n \nensure-path\n \n \nhandler\n \n \nwith-context\n \narachne.http.dsl.test\nContains DSL forms for defining a HTTP server in the configuration, with a runtime\nimplementation that does exactly nothing. Useful for testing and not much else.\nPublic variables and functions:\n \ncreate-dummy-server\n \n \ndummy-server\n \narachne.http.schema\nPublic variables and functions:\n \nschema\n \narachne.http.validators\nPublic variables and functions:\n \nadd-validators\n \n \nlegal-methods\n \n \nmethod-types\n \n \nunique-endpoint-names\n \n \nvalid-route-segments\n \n \nvalidators\n \narachne.log\nCommon logging layer for all Arachne apps and modules.\nPublic variables and functions:\n \ndebug\n \n \nerror\n \n \ninfo\n \n \ntrace\n \n \nwarn\n \narachne.pedestal\nPublic variables and functions:\n \ncomponent-interceptor\n \n \nconfigure\n \n \nschema\n \narachne.pedestal.config\nPublic variables and functions:\n \nadd-default-interceptors\n \n \nadd-endpoint-types\n \n \nadd-interceptor-default-ordering\n \n \nadd-server-interceptor-deps\n \n \nfind-route-interceptors\n \n \ninterceptor-rules\n \narachne.pedestal.dsl\nPublic variables and functions:\n \ncreate-server\n \n \ninterceptor\n \n \nserver\n \narachne.pedestal.routes\nPublic variables and functions:\n \ninterceptor\n \n \ninterceptors-for\n \n \nroutes\n \narachne.pedestal.schema\nPublic variables and functions:\n \nschema\n \narachne.pedestal.server\nPublic variables and functions:\n \nconstructor\n \narachne.pedestal.specs\nPublic variables and functions:\narachne.run\nApplication entry point for running an Arachne application\nPublic variables and functions:\n \n-main", 
            "title": "API Documentation"
        }
    ]
}